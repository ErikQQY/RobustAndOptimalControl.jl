var documenterSearchIndex = {"docs":
[{"location":"#RobustAndOptimalControl.jl","page":"Home","title":"RobustAndOptimalControl.jl","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"pkg> add RobustAndOptimalControl","category":"page"},{"location":"#Named-systems","page":"Home","title":"Named systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"named_ss","category":"page"},{"location":"#Connecting-systems-together","page":"Home","title":"Connecting systems together","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"connect","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following complicated feedback interconnection","category":"page"},{"location":"","page":"Home","title":"Home","text":"                 yF\n              ┌────────────────────────────────┐\n              │                                │\n    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐\nuF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP\n────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►\n    │       │    │       │   ┌──►         │         │       │    │\n    └───────┘    └───────┘   │  └─────────┘         └───────┘    │\n                             │                                   │\n                             └───────────────────────────────────┘","category":"page"},{"location":"","page":"Home","title":"Home","text":"can be created by","category":"page"},{"location":"","page":"Home","title":"Home","text":"F = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)\nR = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)\nC = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)\nP = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)\n\naddP = sumblock(\"uP = yF + yC\") # Sum node before P\naddC = sumblock(\"uC = yR - yP\") # Sum node before C\n\nconnections = [\n    :yP => :yP # Output to input\n    :uP => :uP\n    :yC => :yC\n    :yF => :yF\n    :yF => :uR\n    :uC => :uC\n    :yR => :yR\n]\nw1 = [:uF] # External inputs\n\nG = connect([F, R, C, P, addP, addC], connections; w1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If an external input is to be connected to multiple points, use a splitter to split up the signal into a set of unique names which are then used in the connections.","category":"page"},{"location":"#Uncertainty-modeling","page":"Home","title":"Uncertainty modeling","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO: add examples","category":"page"},{"location":"","page":"Home","title":"Home","text":"neglected_delay\nneglected_lag\ngain_and_delay_uncertainty\nmakeweight\nfit_complex_perturbations","category":"page"},{"location":"#Model-augmentation","page":"Home","title":"Model augmentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO","category":"page"},{"location":"","page":"Home","title":"Home","text":"add_disturbance\nadd_measurement_disturbance\nadd_input_differentiator\nadd_output_differentiator\nadd_input_integrator\nadd_output_integrator\nadd_low_frequency_disturbance\nadd_resonant_disturbance","category":"page"},{"location":"#H_\\infty-and-H_2-design","page":"Home","title":"H_infty and H_2 design","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO Examples are available in the example folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"hinfsynthesize\nh2synthesize","category":"page"},{"location":"#LQG-design","page":"Home","title":"LQG design","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO","category":"page"},{"location":"","page":"Home","title":"Home","text":"LQGProblem","category":"page"},{"location":"#Structured-singular-value-and-diskmargin","page":"Home","title":"Structured singular value and diskmargin","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO","category":"page"},{"location":"#Closed-loop-analysis","page":"Home","title":"Closed-loop analysis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"output_sensitivity\noutput_comp_sensitivity\ninput_sensitivity\ninput_comp_sensitivity\nG_CS\nG_PS\ngangoffour","category":"page"},{"location":"#Exported-functions-and-types","page":"Home","title":"Exported functions and types","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [RobustAndOptimalControl]\nPrivate = false","category":"page"},{"location":"#RobustAndOptimalControl.LQGProblem","page":"Home","title":"RobustAndOptimalControl.LQGProblem","text":"G = LQG(sys::AbstractStateSpace, Q1, Q2, R1, R2; qQ=0, qR=0, M = I, N = I)\n\nReturn an LQG object that describes the closed control loop around the process sys=ss(A,B,C,D) where the controller is of LQG-type. The controller is specified by weight matrices Q1,Q2 that penalizes state deviations and control signal variance respectively, and covariance matrices R1,R2 which specify state drift and measurement covariance respectively.\n\nqQ and qR can be set to incorporate loop transfer recovery, i.e.,\n\nL = lqr(A, B, Q1+qQ*C'C, Q2)\nK = kalman(A, C, R1+qR*B*B', R2)\n\nIncreasing qQ will add more cost in output direction, e.g., encouraging the use of cheap control, while increasing qR adds fictious dynamics noise, makes the observer faster.\n\nM is a matrix that defines the controlled variables z, i.e., the variables for which you provide reference signals. If no M is provided, the default is to consider all state variables of the system as controlled. The definitions of z and y are given below\n\ny = C*x\nz = M*x\n\nsize(M, 1) determines the size of the Q1 matrix you need to supply.\n\nN is a matrix that defines how the dynamics noise v enters the system, i.e. If no N is provided, the default is to consider all state variables being affected by independent noise components. The definition of v is given below\n\nx′ = A*x + B*u + N*v\n\nsize(N, 2) determines the size of the R1 matrix you need to supply.\n\nExample\n\ns = tf(\"s\")\nP = [1/(s+1) 2/(s+2); 1/(s+3) 1/(s-1)]\nsys = ss(P)\neye(n) = Matrix{Float64}(I,n,n) # For convinience\n\nqQ = 1\nqR = 1\nQ1 = 10eye(4)\nQ2 = 1eye(2)\nR1 = 1eye(6)\nR2 = 1eye(2)\n\nG = LQG(sys, Q1, Q2, R1, R2, qQ=qQ, qR=qR)\n\nGcl = G.cl\nT = G.T\nS = G.S\nsigmaplot([S,T],exp10.(range(-3, stop=3, length=1000)))\nstepplot(Gcl)\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.LQGProblem-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.LQGProblem","text":"LQGProblem(P::ExtendedStateSpace)\n\nIf only an ExtendedStateSpace system is provided, the system P is assumed to correspond to the H₂ optimal control problem with\n\nC1'C1    = Q1\nD12'D12  = Q2\n\nB1*B1'   = R1\nD21*D21' = R2\n\nand an LQGProblem with the above covariance matrices is returned. The system description in the returned LQGProblem will have B1 = C1 = I. See Ch. 13 in Robust and optimal control for reference. \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.NamedStateSpace","page":"Home","title":"RobustAndOptimalControl.NamedStateSpace","text":"See named_ss for a convenient constructor.\n\n\n\n\n\n","category":"type"},{"location":"#RobustAndOptimalControl.add_disturbance-Tuple{ControlSystems.AbstractStateSpace, AbstractMatrix{T} where T, AbstractMatrix{T} where T}","page":"Home","title":"RobustAndOptimalControl.add_disturbance","text":"add_disturbance(sys::AbstractStateSpace, Ad::AbstractMatrix, Cd::AbstractMatrix)\n\nSee CCS pp. 144\n\nArguments:\n\nsys: System to augment\nAd: The dynamics of the disturbance\nCd: How the disturbance states affect the states of sys. This matrix has the shape (sys.nx, size(Ad, 1))\n\nSee also add_low_frequency_disturbance, add_resonant_disturbance\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.add_input_differentiator","page":"Home","title":"RobustAndOptimalControl.add_input_differentiator","text":"add_input_differentiator(sys::AbstractStateSpace, ui = 1:sys.nu; goodwin=false)\n\nAugment the output of sys with the difference u(k+1)-u(k)\n\nArguments:\n\nui: An index or vector of indices indicating which inputs to differentiate.\ngoodwin: If true, the difference operator will use the Goodwin δ operator, i.e., (u(k+1)-u(k)) / sys.Ts.\n\nThe augmented system will have the matrices\n\n[A 0; 0 0]  [B; I]  [C 0; 0 -I]  [D; I]\n\nwith length(ui) added states and outputs.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_input_integrator","page":"Home","title":"RobustAndOptimalControl.add_input_integrator","text":"add_input_integrator(sys::AbstractStateSpace, ui = 1, ϵ = 0)\n\nAugment the output of sys with the integral of input at index ui, i.e.,  y_aug = [y; ∫u[ui]]\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_output_differentiator","page":"Home","title":"RobustAndOptimalControl.add_output_differentiator","text":"add_differentiator(sys::AbstractStateSpace{<:Discrete})\n\nAugment the output of sys with the numerical difference (discrete-time derivative) of output, i.e., y_aug = [y; (y-y_prev)/sys.Ts] To add both an integrator and a differentiator to a SISO system, use\n\n\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.add_output_integrator","page":"Home","title":"RobustAndOptimalControl.add_output_integrator","text":"addoutputintegrator(sys::AbstractStateSpace{<:Discrete}, ind = 1; ϵ = 0)\n\nAugment the output of sys with the integral of output at index ind, i.e.,  y_aug = [y; ∫y[ind]] To add both an integrator and a differentiator to a SISO system, use\n\nGd = add_output_integrator(add_output_differentiator(G), 1)\n\nNote: numerical integration is subject to numerical drift. If the output of the system corresponds to, e.g., a velocity reference and the integral to position reference, consider methods for mitigating this drift.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.bilinearc2d-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}","page":"Home","title":"RobustAndOptimalControl.bilinearc2d","text":"bilinearc2d(Ac::AbstractArray, Bc::AbstractArray, Cc::AbstractArray, Dc::AbstractArray, Ts::Number; tolerance=1e-12)\n\nBalanced Bilinear transformation in State-Space. This method computes a discrete time equivalent of a continuous-time system, such that\n\nG_d(z) = s2z[G_c(s)]\n\nin a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||2=||C||2   (iii) Satisfies Gc(s) = z2s[s2z[Gc(s)]] for some map z2s[]\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilinearc2d-Tuple{ControlSystems.StateSpace{ControlSystems.Continuous, T} where T, Number}","page":"Home","title":"RobustAndOptimalControl.bilinearc2d","text":"bilinearc2d(sys::StateSpace, Ts::Number)\n\nApplies a Balanced Bilinear transformation to a discrete-time statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilinearc2d-Tuple{ExtendedStateSpace{ControlSystems.Continuous, T} where T, Number}","page":"Home","title":"RobustAndOptimalControl.bilinearc2d","text":"bilinearc2d(sys::ExtendedStateSpace, Ts::Number)\n\nApplies a Balanced Bilinear transformation to a discrete-time extended statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilineard2c-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, Number}","page":"Home","title":"RobustAndOptimalControl.bilineard2c","text":"bilineard2c(Ad::AbstractArray, Bd::AbstractArray, Cd::AbstractArray, Dd::AbstractArray, Ts::Number; tolerance=1e-12)\n\nBalanced Bilinear transformation in State-Space. This method computes a continuous time equivalent of a discrete time system, such that\n\nG_c(z) = z2s[G_d(z)]\n\nin a manner which accomplishes the following   (i)   Preserves the infinity L-infinity norm over the transformation   (ii)  Finds a system which balances B and C, in the sense that ||B||2=||C||2   (iii) Satisfies Gd(z) = s2z[z2s[Gd(z)]] for some map s2z[]\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilineard2c-Tuple{ControlSystems.StateSpace}","page":"Home","title":"RobustAndOptimalControl.bilineard2c","text":"bilineard2c(sys::StateSpace)\n\nApplies a Balanced Bilinear transformation to continuous-time statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.bilineard2c-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.bilineard2c","text":"bilineard2c(sys::ExtendedStateSpace)\n\nApplies a Balanced Bilinear transformation to continuous-time extended statespace object\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.closedloop","page":"Home","title":"RobustAndOptimalControl.closedloop","text":"closedloop(l::LQGProblem, L = lqr(l), K = kalman(l))\n\nClosed-loop system as defined in Glad and Ljung eq. 8.28\n\nThe return value will be the closed loop from reference only, other disturbance signals (B1) are ignored. See feedback for a more advanced option.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.comp_sensitivity-Tuple","page":"Home","title":"RobustAndOptimalControl.comp_sensitivity","text":"See output_comp_sensitivity\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.connect-Tuple{Any}","page":"Home","title":"RobustAndOptimalControl.connect","text":"connect(systems, connections; w1, z1 = (:), verbose = true, kwargs...)\n\nCreate complicated feedback interconnection. \n\nAddition and subtraction nodes are achieved by creating a linear combination node, i.e., a system with a D matrix only.\n\nArguments:\n\nsystems: A vector of named systems to be connected\nconnections: a vector of pairs indicating output => input mappings.\nu1: input mappings  (alternative input argument)\ny1: output mappings (alternative input argument)\nw1: external signals\nz1: outputs (can overlap with y1)\nverbose: Issue warnings for signals that have no connection\n\nExample: The following complicated feedback interconnection\n\n                 yF\n              ┌────────────────────────────────┐\n              │                                │\n    ┌───────┐ │  ┌───────┐ yR   ┌─────────┐    │    ┌───────┐\nuF  │       │ │  │       ├──────►         │ yC │  uP│       │    yP\n────►   F   ├─┴──►   R   │      │    C    ├────+────►   P   ├────┬────►\n    │       │    │       │   ┌──►         │         │       │    │\n    └───────┘    └───────┘   │  └─────────┘         └───────┘    │\n                             │                                   │\n                             └───────────────────────────────────┘\n\ncan be created by\n\nF = named_ss(ssrand(1, 1, 2, proper=true), x=:xF, u=:uF, y=:yF)\nR = named_ss(ssrand(1, 1, 2, proper=true), x=:xR, u=:uR, y=:yR)\nC = named_ss(ssrand(1, 1, 2, proper=true), x=:xC, u=:uC, y=:yC)\nP = named_ss(ssrand(1, 1, 3, proper=true), x=:xP, u=:uP, y=:yP)\n\naddP = sumblock(\"uP = yF + yC\") # Sum node before P\naddC = sumblock(\"uC = yR - yP\") # Sum node before C\n\nconnections = [\n    :yP => :yP # Output to input\n    :uP => :uP\n    :yC => :yC\n    :yF => :yF\n    :yF => :uR\n    :uC => :uC\n    :yR => :yR\n]\nw1 = [:uF] # External inputs\n\nG = connect([F, R, C, P, addP, addC], connections; w1)\n\nIf an external input is to be connected to multiple points, use a splitter to split up the signal into a set of unique names which are then used in the connections.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.controller_reduction","page":"Home","title":"RobustAndOptimalControl.controller_reduction","text":"controller_reduction(P, K, r, out=false)\n\nMinimize    ||(K-Kᵣ) W||∞ if out=false             ||W (K-Kᵣ)||∞ if out=true See Robust and Optimal Control Ch 19.1 out indicates if the weight will be applied as output or input weight.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.expand_symbol-Tuple{Symbol, Int64}","page":"Home","title":"RobustAndOptimalControl.expand_symbol","text":"expand_symbol(s::Symbol, n::Int)\n\nTakes a symbol and an integer and returns a vector of symbols with increasing numbers appended to the end. E.g., (:x, 3) -> [:x1, :x2, :x3]\n\nThe short-hand syntax s^n is also available, e.g., :x^3 == expand_symbol(:x, 3).\n\nUseful to create signal names for named systems.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.extended_controller","page":"Home","title":"RobustAndOptimalControl.extended_controller","text":"extended_controller(l::LQGProblem, L = lqr(l), K = kalman(l))\n\nReturns an expression for the controller that is obtained when state-feedback u = -L(xᵣ-x̂) is combined with a Kalman filter with gain K that produces state estimates x̂. The controller is an instance of ExtendedStateSpace where C2 = -L, D21 = L and B2 = K.\n\nThe returned system has inputs [xᵣ; y] and outputs the control signal u. If a reference model R is used to generate state references xᵣ, the controller from e = ry - y -> u is given by\n\nCe = extended_controller(l)\nCe = named_ss(Ce; x = :xC, y = :u, u = [R.y; :y^l.ny]) # Name the inputs of Ce the same as the outputs of `R`.\nconnect([R, Ce]; u1 = R.y, y1 = R.y, w1 = [:ry^l.ny, :y^l.ny], z1=[:u])\n\nSince the negative part of the feedback is built into the returned system, we have C = observer_controller(l) Ce = extended_controller(l) system_mapping(Ce) == -C`\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.extended_controller-Tuple{ControlSystems.AbstractStateSpace}","page":"Home","title":"RobustAndOptimalControl.extended_controller","text":"extended_controller(K::AbstractStateSpace)\n\nTakes a controller and returns an ExtendedStateSpace version which has augmented input [r; y] and output y (z output is 0-dim).\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.find_lft-Union{Tuple{F}, Tuple{N}, Tuple{ControlSystems.StateSpace{var\"#s228\", var\"#s227\"} where {var\"#s228\", var\"#s227\"<:(MonteCarloMeasurements.StaticParticles{var\"#s226\", N} where var\"#s226\")}, Any}, Tuple{ControlSystems.StateSpace{var\"#s225\", var\"#s224\"} where {var\"#s225\", var\"#s224\"<:(MonteCarloMeasurements.StaticParticles{var\"#s223\", N} where var\"#s223\")}, Any, F}} where {N, F}","page":"Home","title":"RobustAndOptimalControl.find_lft","text":"l = find_lft(sys::StateSpace{<:Any, <:StaticParticles{<:Any, N}}, δ) where N\n\nGiven an systems sys with uncertain coefficients in the form of StaticParticles, find a lower linear fractional transformation M such that lft(M, δ) ≈ sys. \n\nδ can be either the source of uncertainty in sys, i.e., a vector of the unique uncertain parameters that were used to create sys. These should be constructed as uniform randomly distributed particles for most robust-control theory to be applicable.  δ can also be an integer, in which case a numer of δ sources of uncertainty are automatically created. This could be used for order reduction if the number of uncertainty sources in sys is large.\n\nNote, uncertainty in sys is only supported in A and B, C and D must be deterministic.\n\nReturns l::LFT that internaly contains all four blocks of M as well as δ. Call ss(l,sys) do obtain lft(M, δ) ≈ sys.\n\nCall Matrix(l) to obtain M = [M11 M12; M21 M22]\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.frequency_weighted_reduction-NTuple{4, Any}","page":"Home","title":"RobustAndOptimalControl.frequency_weighted_reduction","text":"frequency_weighted_reduction(G, Wo, Wi)\n\nFind Gr such that ||Wₒ(G-Gr)Wᵢ||∞ is minimized. For a realtive reduction, set Wo = inv(G) and Wi = I.\n\nRef: Robust and Optimal Control ch. 7.2\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.glover_mcfarlane","page":"Home","title":"RobustAndOptimalControl.glover_mcfarlane","text":"K, γmin = glover_mcfarlane(G::AbstractStateSpace{Continuous}, γ = 1.1)\n\nDesign a controller for G that maximizes the stability margin ϵ = 1/γ with normalized coprime factor uncertainty using the method of Glover and McFarlane\n\nγ = 1/ϵ = ||[K;I] inv(I-G*K)*inv(M)||∞\nG = inv(M + ΔM)*(N + ΔN)\n\nγ is given as a relative factor above γmin and must be greater than 1, i.e., if γ = 1.1, the controller will be designed for γ = 1.1*γmin.\n\nWe want γmin ≥ 1 as small as possible, and we usually require that min is less than 4, corresponding to 25% allowed coprime uncertainty.\n\nPerformance modeling is incorporated in the design by calling glover_mcfarlane on the shaped system W2*G*W1 and then forming the controller as W1*K*W2. Using this formulation, traditional loop shaping can be done on W2*G*W1. Too many options? Select W2 diagonal with a small weight for less important outputs. Skogestad gives the following general advice:\n\nScale the plant outputs and inputs. This is very important for most design  procedures and is sometimes forgotten. In general, scaling improves the  conditioning of the design problem, it enables meaningful analysis to be made  of the robustness properties of the feedback system in the frequency domain,  and for loop-shaping it can simplify the selection of weights. There are a variety  of methods available including normalization with respect to the magnitude of  the maximum or average value of the signal in question. Scaling with respect to  maximum values is important if the controllability analysis of earlier chapters is  to be used. However, if one is to go straight to a design the following variation has  proved useful in practice:  (a) The outputs are scaled such that equal magnitudes of cross-coupling into each      of the outputs is equally undesirable.  (b) Each input is scaled by a given percentage (say 10%) of its expected range      of operation. That is, the inputs are scaled to reflect the relative actuator      capabilities. An example of this type of scaling is given in the aero-engine      case study of Chapter 12.\nOrder the inputs and outputs so that the plant is as diagonal as possible. The  relative gain array can be useful here. The purpose of this pseudo-diagonalization  is to ease the design of the pre- and post-compensators which, for simplicity, will  be chosen to be diagonal.\nNext, we discuss the selection of weights to obtain the shaped plant Gs = W2GW1  where W1 = Wp Wa Wg\nSelect the elements of diagonal pre- and post-compensators Wp and W2 so that  the singular values of W2 G Wp are desirable. This would normally mean high  gain at low frequencies, roll-off rates of approximately 20 dB/decade (a slope of  about 1) at the desired bandwidth(s), with higher rates at high frequencies. Some  trial and error is involved here. W2 is usually chosen as a constant, reflecting the  relative importance of the outputs to be controlled and the other measurements  being fed back to the controller. For example, if there are feedback measurements  of two outputs to be controlled and a velocity signal, then W2 might be chosen  to be diag[1, 1, 0.1], where 0.1 is in the velocity signal channel. W p contains the  dynamic shaping. Integral action, for low frequency performance; phase-advance  for reducing the roll-off rates at crossover; and phase-lag to increase the roll-off  rates at high frequencies should all be placed in Wp if desired. The weights should  be chosen so that no unstable hidden modes are created in Gs.\nOptional: Introduce an additional gain matrix Wg cascaded with Wa to provide  control over actuator usage. Wg is diagonal and is adjusted so that actuator rate  limits are not exceeded for reference demands and typical disturbances on the  scaled plant outputs. This requires some trial and error.\nRobustly stabilize the shaped plant Gs = W2*G*W1 , where W1 = Wp Wa Wg,  using glover_mcfarlane. First, the maximum stability  margin ϵmax = 1/γmin is calculated. If the margin is too small, ϵmax < 0.25, then go back to step 5 and modify the weights. Otherwise, a γ-suboptimal controller is synthesized. There is usually no advantage to be gained by using the optimal controller. When ϵmax > 0.25  (respectively γmin < 4) the design is usually successful. In this case, at least  25% coprime factor uncertainty is allowed, and we also find that the shape of the  open-loop singular values will not have changed much after robust stabilization.  A small value of ϵmax indicates that the chosen singular value loop-shapes are  incompatible with robust stability requirements. That the loop-shapes do not  change much following robust stabilization if γ is small (ϵ large), is justified  theoretically in McFarlane and Glover (1990).\nAnalyze the design and if all the specifications are not met make further  modifications to the weights.\nImplement the controller. The configuration shown in below has been found  useful when compared with the conventional set up. This is because  the references do not directly excite the dynamics of Ks, which can result in large amounts of overshoot (classical derivative kick). The constant prefilter ensures a steady-state gain of 1 between r and y, assuming integral action in W1 or G (note, the K returned by this function has opposite sign compared to that of Skogestad, so we use negative feedback here).\n\n       ┌─────────┐      ┌────────┐      ┌────────┐\n    r  │         │ -  us│        │  u   │        │  y\n   ───►│(K*W2)(0)├──+──►│   W1   ├─────►│   G    ├────┬──►\n       │         │  │+  │        │      │        │    │\n       └─────────┘  │   └────────┘      └────────┘    │\n                    │                                 │\n                    │                                 │\n                    │   ┌────────┐      ┌────────┐    │\n                    │   │        │  ys  │        │    │\n                    └───┤   K    │◄─────┤   W2   │◄───┘\n                        │        │      │        │\n                        └────────┘      └────────┘\n\nExample:\n\nExample 9.3 from the reference below.\n\nusing RobustAndOptimalControl, ControlSystems, Plots\nG = tf(200, [10, 1])*tf(1, [0.05, 1])^2     |> ss\nGd = tf(100, [10, 1])                       |> ss\nW1 = tf([1, 2], [1, 1e-6])                  |> ss\nGs = G*W1\nKs, γmin = glover_mcfarlane(Gs, 1.1)\n@test γmin ≈ 2.34 atol=0.005\n\nbodeplot([G, Gs, Gs*Ks]) |> display\n\nplot( step(Gd*feedback(1, G*W1), 3))\nplot!(step(Gd*feedback(1, G*W1*Ks), 3)) |> display\n\nnyquistplot([G*W1, G*W1*Ks], ylims=(-2,1), xlims=(-2, 1), Ms_circles=1.5) |> display\n\nAnti-windup can be added to W1 but putting W1 on Hanus form after the synthesis, see hanus.\n\nRef: Sec 9.4.1 of Skogestad, \"Multivariable Feedback Control: Analysis and Design\"\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.h2synthesize","page":"Home","title":"RobustAndOptimalControl.h2synthesize","text":"K, Cl = h2synthesize(P::ExtendedStateSpace, γ = nothing)\n\nSynthesize H₂-optimal controller K and calculate the closed-loop transfer function from w to z. Ref: Cha. 14.5 in Robust and Optimal Control.\n\nIf γ = nothing, use the formulas for H₂ in Ch 14.5. If γ is a large value, the H∞ formulas are used. As γ → ∞, these two are equivalent. The h∞ formulas do a coordinate transfromation that handles slightly more general systems so if you run into an error, it might be worth trying setting γ to something large, e.g., 1000.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.hanus-Tuple{Any}","page":"Home","title":"RobustAndOptimalControl.hanus","text":"hanus(W)\n\nReturn Wh on Hanus form. Wh has twice the number of inputs, where the second half of the inputs are \"actual inputs\", e.g., potentially saturated. This is used to endow W with anti-windup protection. W must have an invertable D matrix and be minimum phase.\n\nRef: Sec 9.4.5 of Skogestad, \"Multivariable Feedback Control: Analysis and Design\"\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfassumptions-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.hinfassumptions","text":"flag = hinfassumptions(P::ExtendedStateSpace; verbose=true)\n\nCheck the assumptions for using the γ-iteration synthesis in Theorem 1.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfpartition-NTuple{4, Any}","page":"Home","title":"RobustAndOptimalControl.hinfpartition","text":"P = hinfpartition(G, WS, WU, WT)\n\nTransform a SISO or MIMO system G, with weighting functions WS, WU, WT into and LFT with an isolated controller, and write the resulting system, P(s), on a state-space form. Valid inputs for G are transfer functions (with dynamics, can be both MIMO and SISO, both in tf and ss forms). Valid inputs for the weighting functions are empty arrays, numbers (static gains), and LTISystems.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfsignals-Tuple{ExtendedStateSpace, ControlSystems.LTISystem, ControlSystems.LTISystem}","page":"Home","title":"RobustAndOptimalControl.hinfsignals","text":"hinfsignals(P::ExtendedStateSpace, G::LTISystem, C::LTISystem)\n\nUse the extended state-space model, a plant and the found controller to extract the closed loop transfer functions operating solely on the state-space.\n\nPcl : w → z : From input to the weighted functions\nS   : w → e : From input to error\nCS  : w → u : From input to control\nT   : w → y : From input to output\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hinfsynthesize-Tuple{ExtendedStateSpace}","page":"Home","title":"RobustAndOptimalControl.hinfsynthesize","text":"flag, K, γ, mats = hinfsynthesize(P::ExtendedStateSpace; maxIter=20, interval=(2/3,20), verbose=true)\n\nComputes an H-infinity optimal controller K for an extended plant P such that ||F_l(P, K)||∞ < γ for the largest possible γ given P. The routine is known as the γ-iteration, and is based on the paper \"State-space formulae for all stabilizing controllers that satisfy an H∞-norm bound and relations to risk sensitivity\" by Glover and Doyle. See the Bib-entry below [1] above.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.hsvd-Tuple{ControlSystems.AbstractStateSpace{ControlSystems.Continuous}}","page":"Home","title":"RobustAndOptimalControl.hsvd","text":"hsvd(sys::AbstractStateSpace{Continuous})\n\nReturn the Hankel singular values of sys, computed as the eigenvalues of QP Where Q and P are the Gramians of sys.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.input_comp_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.input_comp_sensitivity","text":"input_comp_sensitivity(P,C)\ninput_comp_sensitivity(l::LQGProblem)\n\nTransfer function from load disturbance to control signal.\n\n\"Input\" signifies that the transfer function is from the input of the plant.\n\"Complimentary\" signifies that the transfer function is to an output (in this case controller output)\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.input_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.input_sensitivity","text":"input_sensitivity(P, C)\ninput_sensitivity(l::LQGProblem)\n\nTransfer function from load disturbance to total plant input.\n\n\"Input\" signifies that the transfer function is from the input of the plant.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.measure-Tuple{NamedStateSpace, Any}","page":"Home","title":"RobustAndOptimalControl.measure","text":"measure(s::NamedStateSpace, names)\n\nReturn a system with specified states as measurement outputs.\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.named_ss-Union{Tuple{ControlSystems.AbstractStateSpace{T}}, Tuple{T}} where T","page":"Home","title":"RobustAndOptimalControl.named_ss","text":"named_ss(sys::AbstractStateSpace{T}; x, u, y)\n\nCreate a NamedStateSpace system. This kind of system uses names rather than integer indices to refer to states, inputs and outputs\n\nArguments:\n\nsys: A system to add names to.\nx: A list of symbols with names of the states.\nu: A list of symbols with names of the inputs.\ny: A list of symbols with names of the outputs.\n\nDefault names of signals if none are provided are x,u,y.\n\nExample\n\nG1 = ss(1,1,1,0)\nG2 = ss(1,1,1,0)\ns1 = named_ss(G1, x = :x, u = :u1, y=:y1)\ns2 = named_ss(G2, x = :z, u = :u2, y=:y2)\n\ns1[:y1, :u1] # Index using symbols\n\nfb = feedback(s1, s2, r = :r) # \n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.output_comp_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.output_comp_sensitivity","text":"output_comp_sensitivity(P,C)\noutput_comp_sensitivity(l::LQGProblem)\n\nTransfer function from measurement noise / reference to plant output.\n\n\"output\" signifies that the transfer function is from the output of the plant.\n\"Complimentary\" signifies that the transfer function is to an output (in this case plant output)\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.output_sensitivity-Tuple{Any, Any}","page":"Home","title":"RobustAndOptimalControl.output_sensitivity","text":"output_sensitivity(P, C)\noutput_sensitivity(l::LQGProblem)\n\nTransfer function from measurement noise / reference to control signal.\n\n\"output\" signifies that the transfer function is from the output of the plant.\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.sensitivity-Tuple","page":"Home","title":"RobustAndOptimalControl.sensitivity","text":"See output_sensitivity\n\n         ▲\n         │e₁\n         │  ┌─────┐\nd₁────+──┴──►  P  ├─────┬──►e₄\n      │-    └─────┘     │\n      │                 │\n      │     ┌─────┐     │\n e₂◄──┴─────┤  C  ◄──┬──+───d₂\n            └─────┘  │\n                     │e₃\n                     ▼\n\nInput  sensitivity is the transfer function from d₁ to e₁,                 (I + CP)⁻¹\nOutput sensitivity is the transfer function from d₂ to e₂,                 (I + PC)⁻¹\nInput  complementary sensitivity is the transfer function from d₁ to e₂, CP(I + CP)⁻¹\nOutput complementary sensitivity is the transfer function from d₂ to e₄, PC(I + PC)⁻¹\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.specificationplot","page":"Home","title":"RobustAndOptimalControl.specificationplot","text":"specificationplot([S,CS,T], [WS,WU,WT])\n\nThis function visualizes the control synthesis using the hInf_synthesize with the three weighting functions {WS(jω), WU(jω), WT(jω)} inverted and scaled by γ, against the corresponding transfer fucntions {S(jω), C(jω)S(jω), T(jω)}, to verify visually that the specifications are met. This may be run using both MIMO and SISO systems.\n\n\n\n\n\n","category":"function"},{"location":"#RobustAndOptimalControl.sumblock-Tuple{String}","page":"Home","title":"RobustAndOptimalControl.sumblock","text":"sumblock(ex::String; Ts = 0, n = 1)\n\nCreate a summation node that sums (or subtracts) vectors of length n.\n\nArguments:\n\nTs: Sample time\nn: The length of the input and output vectors. Set n=1 for scalars.\n\nExamples:\n\njulia> sumblock(\"uP = vf + yL\")\nNamedStateSpace{Continuous, Int64}\nD = \n 1  1\n\nWith state  names: \n     input  names: vf yL\n     output names: uP\n\n\njulia> sumblock(\"x_diff = xr - xh\"; n=3)\nNamedStateSpace{Continuous, Int64}\nD = \n 1  0  0  -1   0   0\n 0  1  0   0  -1   0\n 0  0  1   0   0  -1\n\nWith state  names: \n     input  names: xr1 xr2 xr3 xh1 xh2 xh3\n     output names: x_diff1 x_diff2 x_diff3\n     \n\njulia> sumblock(\"a = b + c - d\")\nNamedStateSpace{Continuous, Int64}\nD = \n 1  1  -1\n\nWith state  names: \n     input  names: b c d\n     output names: a\n\n\n\n\n\n","category":"method"},{"location":"#RobustAndOptimalControl.δ","page":"Home","title":"RobustAndOptimalControl.δ","text":"δ(N=32)\n\nCreate an uncertain element of N uniformly distributed samples ∈ [-1, 1]\n\n\n\n\n\n","category":"function"}]
}
