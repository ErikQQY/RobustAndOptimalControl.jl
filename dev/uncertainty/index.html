<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Uncertainty modeling · RobustAndOptimalControl Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">RobustAndOptimalControl Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Uncertainty modeling</a><ul class="internal"><li><a class="tocitem" href="#Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/.MonteCarloMeasurements.jl)"><span>Parametric uncertainty using MonteCarloMeasurements.jl</span></a></li><li><a class="tocitem" href="#Using-the-M\\Delta-framework"><span>Using the <span>$M\Delta$</span> framework</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Uncertainty modeling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Uncertainty modeling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/docs/src/uncertainty.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Uncertainty-modeling"><a class="docs-heading-anchor" href="#Uncertainty-modeling">Uncertainty modeling</a><a id="Uncertainty-modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertainty-modeling" title="Permalink"></a></h1><p>See example <a href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/examples/uncertain.jl"><code>uncertain.jl</code></a>.</p><ul><li><a href="../#RobustAndOptimalControl.δc"><code>δc</code></a> Creates an uncertain complex parameter.</li><li><a href="../#RobustAndOptimalControl.δr"><code>δr</code></a> Creates an uncertain real parameter.</li><li><a href="@ref"><code>δss</code></a> (Experimental) Creates an uncertain statespace model.</li><li><a href="@ref"><code>neglected_delay</code></a></li><li><a href="@ref"><code>neglected_lag</code></a></li><li><a href="@ref"><code>gain_and_delay_uncertainty</code></a></li><li><a href="@ref"><code>makeweight</code></a></li><li><a href="@ref"><code>fit_complex_perturbations</code></a></li></ul><p>We provide two general means of modeling uncertainty, the traditional <span>$M\Delta$</span> framework <sup class="footnote-reference"><a id="citeref-Skogestad" href="#footnote-Skogestad">[Skogestad]</a></sup><sup class="footnote-reference"><a id="citeref-Doyle91" href="#footnote-Doyle91">[Doyle91]</a></sup>, and a Monte-Carlo approach using <a href="https://github.com/baggepinnen/.MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a></p><h2 id="Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/.MonteCarloMeasurements.jl)"><a class="docs-heading-anchor" href="#Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/.MonteCarloMeasurements.jl)">Parametric uncertainty using <a href="https://github.com/baggepinnen/.MonteCarloMeasurements.jl">MonteCarloMeasurements.jl</a></a><a id="Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/.MonteCarloMeasurements.jl)-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-uncertainty-using-[MonteCarloMeasurements.jl](https://github.com/baggepinnen/.MonteCarloMeasurements.jl)" title="Permalink"></a></h2><p>The most straightforward way to model uncertainty is to use uncertain parameters, using tools such as <a href="https://github.com/JuliaIntervals/IntervalArithmetic.jl">IntervalArithmetic</a> (strict, worst case guarantees) or <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl">MonteCarloMeasurements</a> (less strict worst-case analysis or probabilistic). In the following, we show an example with MIMO systems with both parametric uncertainty and diagonal, complex uncertainty, adapted from 8.11.3 in Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;. This example is also available as a julia script in <a href="https://github.com/JuliaControl/RobustAndOptimalControl.jl/blob/master/examples/uncertain.jl"><code>uncertain.jl</code></a>.</p><h3 id="Example-in-section-3.7.1,-Spinning-satellite"><a class="docs-heading-anchor" href="#Example-in-section-3.7.1,-Spinning-satellite">Example in section 3.7.1, Spinning satellite</a><a id="Example-in-section-3.7.1,-Spinning-satellite-1"></a><a class="docs-heading-anchor-permalink" href="#Example-in-section-3.7.1,-Spinning-satellite" title="Permalink"></a></h3><pre><code class="language- hljs">using RobustAndOptimalControl, ControlSystems, MonteCarloMeasurements, Plots, LinearAlgebra
default(size=(640,480))
unsafe_comparisons(true)

a = 10
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)
K = ss(1.0I(2))

w = 2π .* exp10.(LinRange(-2, 2, 500))
S, PS, CS, T = RobustAndOptimalControl.gangoffour2(P, K)
sigmaplot(S, w, lab=&quot;S&quot;)
sigmaplot!(T, w, c=2, lab=&quot;T&quot;, ylims=(0.01, 45))</code></pre><p>Both sensitivity functions are very large, expect a non-robust system!</p><p>Next, we add parametric uncertainty</p><pre><code class="language- hljs">a = 10*(1 + 0.1δr(100)) # Create an uncertain parameter with nominal value 10 and 10% uncertainty
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)

Sp, PSp, CSp, Tp = RobustAndOptimalControl.gangoffour2(P, K)
sigmaplot(Sp, w, lab=&quot;S&quot;)
sigmaplot!(Tp, w, c=2, lab=&quot;T&quot;, ylims=(0.01, 100))</code></pre><p>Not only are sensitivity functions large, they vary a lot under the considered uncertainty. We can also plot a step response of one of the sensitivity functions to check how the system behaves</p><pre><code class="language- hljs">plot(step(c2d(Tp, 0.01), 10))</code></pre><p>This kind of plot is quite useful, it immediately tells you that this transfer function appears stable, and that there is uncertainty in the static gain etc.</p><p>Next, we add complex diagonal multiplicative input uncertainty. With input uncertainty of magnitude <span>$ϵ &lt; \dfrac{1}{σ̄(T)}$</span> we are guaranteed robust stability (even for “full-block complex perturbations&quot;)</p><pre><code class="language- hljs">a = 10
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)

W0 = makeweight(0.2, (20,1), 2)
W = I(2) + W0 * diagm([δc(100), δc(100)]) # Create a diagonal complex uncertainty weighted in frequency by W0, use 100 samples
Ps = P*W
Ss, PSs, CSs, Ts = RobustAndOptimalControl.gangoffour2(Ps, K)
sigmaplot(Ss, w, lab=&quot;S&quot;)
sigmaplot!(Ts, w, c=2, lab=&quot;T&quot;, ylims=(0.01, 100))</code></pre><p>Under this uncertainty, the sensitivity could potentially be sky high., note how some of the 100 realizations peak much higher than the others. This is an indication that the system might be unstable.</p><p>With complex entries in the system model, we can&#39;t really plot the step response, but we can plot, e.g., the absolute value</p><pre><code class="language- hljs">res = step(c2d(Ts, 0.01), 10)
plot(res.t, [abs.(res.y)[1,:,1] abs.(res.y)[2,:,2]]) # plot only the diagonal response</code></pre><p>Looks unstable to me. The analysis using <span>$M\Delta$</span> methodology below will also reach this conclusion.</p><h3 id="Example-in-section-3.7.2,-Distillation-Process"><a class="docs-heading-anchor" href="#Example-in-section-3.7.2,-Distillation-Process">Example in section 3.7.2, Distillation Process</a><a id="Example-in-section-3.7.2,-Distillation-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Example-in-section-3.7.2,-Distillation-Process" title="Permalink"></a></h3><pre><code class="language- hljs">using RobustAndOptimalControl, ControlSystems, MonteCarloMeasurements, Plots, LinearAlgebra
default(size=(640,480))
unsafe_comparisons(true)

M = [87.8 -86.4; 108.2 -109.6]
G = ss(tf(1, [75, 1])) * M
RGA = relative_gain_array(G, 0)
sum(abs, RGA) # A good estimate of the true condition number, which is 141.7</code></pre><p>large elements in the RGA indicate a process that is difficult to control</p><p>We consider the following inverse-based controller, which may also be looked upon as a steady-state decoupler with a PI controller</p><pre><code class="language- hljs">k1 = 0.7
Kinv = ss(tf(k1*[75, 1], [1, 0])) * inv(M) 

# reference filter
F = tf(1, [5, 1])

w = 2π .* exp10.(LinRange(-2, 2, 500))
sigmaplot(input_sensitivity(G, Kinv), w)
sigmaplot!(output_sensitivity(G, Kinv), w, c=2)</code></pre><p>Sensitivity looks nice, how about step response</p><pre><code class="language- hljs">plot(step(feedback(G*Kinv)*F, 20))</code></pre><p>Looks excellent..</p><p>We consider again the input gain uncertainty as in the previous example, and we manually select the perturbations to be <span>$ϵ_1 = 0.2$</span> and <span>$ϵ_2 = 0.2$</span>. We then have</p><pre><code class="language- hljs">G′ = G * diagm([1 + 0.2, 1 - 0.2])
plot!(step(feedback(G′*Kinv)*F, 20), l=:dash)</code></pre><p>Looks very poor! The system was not robust to simultaneous input uncertainty!</p><p>We can also do this with a real, diagonal input uncertainty that grows with frequency</p><pre><code class="language- hljs">W0 = Weights.makeweight(0.2, 1, 2.0) # uncertainty goes from 20% at low frequencies to 200% at high frequencies
W = I(2) + W0 * diagm([δr(100), δr(100)])
Gs = G*W

plot(step(feedback(G*Kinv)*F, 20))
plot!(step(feedback(G′*Kinv)*F, 20), l=:dash)
res = step(c2d(feedback(Gs*Kinv)*F, 0.01), 20)
mcplot!(res.t, abs.(res.y[:, :, 1]&#39;), alpha=0.3)
mcplot!(res.t, abs.(res.y[:, :, 2]&#39;), alpha=0.3)</code></pre><p>The system is very sensitive to real input uncertainty!</p><p>With a complex, diagonal uncertainty, modeling both gain and phase variations, it looks slightly worse, but not much worse than with real uncertainty.</p><pre><code class="language- hljs">W = I(2) + W0 * diagm([δc(100), δc(100)]) # note δc instead of δr above
Gs = G*W
res = step(c2d(feedback(Gs*Kinv)*F, 0.01), 20)
mcplot!(res.t, abs.(res.y[:, :, 1]&#39;), alpha=0.3)
mcplot!(res.t, abs.(res.y[:, :, 2]&#39;), alpha=0.3)</code></pre><p>How about the sensitivity functions?</p><pre><code class="language- hljs">Si = input_sensitivity(Gs, Kinv)
sigmaplot(Si, w, c=1, lab=&quot;Si&quot;)
So = output_sensitivity(Gs, Kinv)
sigmaplot!(So, w, c=2, lab=&quot;So&quot;)</code></pre><p>The sensitivity at the plant output is enormous. A low sensitivity with the nominal system does not guarantee robustness!</p><h2 id="Using-the-M\\Delta-framework"><a class="docs-heading-anchor" href="#Using-the-M\\Delta-framework">Using the <span>$M\Delta$</span> framework</a><a id="Using-the-M\\Delta-framework-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-M\\Delta-framework" title="Permalink"></a></h2><p>The examples above never bothered with things like structured singular value, <span>$\mu$</span> or linear-fractional transforms. We do, however, provide some elementary support for this modeling framework.</p><p>In robust control, we often find ourselves having to consider the feedback interconnections below.</p><pre><code class="nohighlight hljs">        ┌─────────┐
  zΔ◄───┤         │◄────wΔ
        │         │
   z◄───┤    P    │◄────w
        │         │
   y◄───┤         │◄────u
        └─────────┘</code></pre><pre><code class="nohighlight hljs">        ┌─────────┐
  zΔ◄───┤         │◄────wΔ
        │         │
   z◄───┤    P    │◄────w
        │         │
   y┌───┤         │◄───┐u
    │   └─────────┘    │
    │                  │
    │      ┌───┐       │
    │      │   │       │
    └─────►│ K ├───────┘
           │   │
           └───┘</code></pre><pre><code class="nohighlight hljs">           ┌───┐
           │   │
    ┌─────►│ Δ ├───────┐
    │      │   │       │
    │      └───┘       │
    │                  │
    │   ┌─────────┐    │
  zΔ└───┤         │◄───┘wΔ
        │         │
   z◄───┤    P    │◄────w
        │         │
   y┌───┤         │◄───┐u
    │   └─────────┘    │
    │                  │
    │      ┌───┐       │
    │      │   │       │
    └─────►│ K ├───────┘
           │   │
           └───┘</code></pre><p>The first block diagram denotes an open-loop system <span>$P$</span> with an uncertainty mapping <span>$w_\Delta = \Delta  z_\Delta$</span>, a <em>performance mapping</em> from <span>$w$</span> to <span>$z$</span> and a input-output mapping between <span>$u$</span> and <span>$y$</span>. Such a system <span>$P$</span> can be partitioned as</p><p class="math-container">\[P = \begin{bmatrix}
P_{11} &amp; P_{12} &amp; P_{13}\\
P_{21} &amp; P_{22} &amp; P_{23}\\
P_{31} &amp; P_{32} &amp; P_{33}\\
\end{bmatrix}\]</p><p>where each <span>$P(s)_{ij}$</span> is a transfer matrix. The type <a href="../#RobustAndOptimalControl.UncertainSS"><code>UncertainSS</code></a> with constructor <a href="../#RobustAndOptimalControl.uss"><code>uss</code></a> represents the block</p><p class="math-container">\[P = \begin{bmatrix}
P_{11} &amp; P_{12}\\
P_{21} &amp; P_{22}\\
\end{bmatrix}\]</p><p>while an <a href="@ref"><code>ExtendedStateSpace</code></a> object represents the block</p><p class="math-container">\[P = \begin{bmatrix}
P_{22} &amp; P_{23}\\
P_{32} &amp; P_{33}\\
\end{bmatrix}\]</p><p>there is thus no type that represents the full system <span>$P$</span> above. However, we provide the function <a href="../#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace}"><code>partition</code></a> which allows you to convert from a regular statespace system to an extended statespace object, and it is thus possible to represent <span>$P$</span> by placing the whole block </p><p class="math-container">\[P = \begin{bmatrix}
P_{22} &amp; P_{23}\\
P_{32} &amp; P_{33}\\
\end{bmatrix}\]</p><p>into <span>$P_{22}$</span> for the purposes of uncertainty analysis, and later use <a href="../#RobustAndOptimalControl.partition-Tuple{ControlSystems.AbstractStateSpace}"><code>partition</code></a> to recover the internal block structure. </p><p>Given an <a href="../#RobustAndOptimalControl.UncertainSS"><code>UncertainSS</code></a> <span>$P$</span>, we can close the loop around <span>$\Delta$</span> by calling <code>starprod(Δ, P)</code> or <code>lft(P, Δ, :u)</code> (note the different order of the arguments), and given an <a href="@ref"><code>ExtendedStateSpace</code></a>, we can close the loop around <code>K</code> by calling <code>starprod(P, K)</code> or <code>lft(P, K)</code> (using positive feedback). This works even if <code>P</code> is a regular statespace object, in which case the convention is that the inputs and outputs are ordered as in the block diagrams above. The number of signals that will be connected by <a href="@ref"><code>lft</code></a> is determined by the input-output arity of <span>$K$</span> and <span>$\Delta$</span> respectively.</p><p>We have the following methods for <code>lft</code> (in addition to the standard ones in ControlSystems.jl)</p><ul><li><code>lft(G::UncertainSS, K::LTISystem)</code> forms the lower LFT closing the loop around <span>$K$</span>.</li><li><code>lft(G::UncertainSS, Δ::AbstractArray=G.Δ)</code> forms the upper LFT closing the loop around <span>$\Delta$</span>.</li><li><code>lft(G::ExtendedStateSpace, K)</code> forms the lower LFT closing the loop around <span>$K$</span>.</li></ul><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><p>We repeat the first example here, but using <span>$M\Delta$</span> formalism rather than direct Monte-Carlo modeling.</p><pre><code class="language- hljs">a = 10
P = ss([0 a; -a 0], I(2), [1 a; -a 1], 0)
W0 = Weights.makeweight(0.2, (1,1), 2)
W = ss(1.0I(2)) + (ss(W0)*I(2)) * uss([δc(), δc()]) # Create a diagonal complex uncertainty weighted in frequency by W0
# note how considerably more verbose the line above is compared to when sampled uncertainties were used, this is an indication of the experimental state of the MΔ tools
Ps = P*W</code></pre><p><code>Ps</code> is now represented as a upper linear fractional transform (upper LFT).</p><p>We can draw samples from this uncertainty representation (sampling of <span>$\Delta$</span> and closing the loop <code>starprod(Δ, Ps)</code>) like so</p><pre><code class="language- hljs">Psamples = rand(Ps, 100)
sigmaplot(Psamples, w)</code></pre><p>We can extract the nominal model using</p><pre><code class="language- hljs">system_mapping(Ps)</code></pre><p>And obtain <span>$M$</span> and <span>$\Delta$</span> when the loop is closed with <span>$K$</span> has</p><pre><code class="language- hljs">lft(Ps, K).M</code></pre><pre><code class="language- hljs">Ps.Δ # Ps.delta also works</code></pre><p>We can evaluate the frequency response of <span>$M$</span> and calculate the structured singular value <span>$\mu$</span></p><pre><code class="language- hljs">M = freqresp(lft(Ps, -K).M, w) # -K to get negative feedback
M = permutedims(M, (2,3,1))
μ = structured_singular_value(M)
plot(w, μ, xscale=:log10)</code></pre><p class="math-container">\[\mu\]</p><p>is very high, whenever <span>$\mu &gt; 1$</span>, the system is not stable with respect to the modeled uncertainty. The tolerated uncertainty is only about <span>$\dfrac{1}{||\mu||_\infty}$</span></p><pre><code class="language- hljs">1/norm(μ, Inf)</code></pre><p>of the modeled uncertainty. Another way of calculating this value is</p><pre><code class="language- hljs">robstab(lft(Ps, -K))</code></pre><h3 id="Internals-of-the-M\\Delta-framework"><a class="docs-heading-anchor" href="#Internals-of-the-M\\Delta-framework">Internals of the <span>$M\Delta$</span> framework</a><a id="Internals-of-the-M\\Delta-framework-1"></a><a class="docs-heading-anchor-permalink" href="#Internals-of-the-M\\Delta-framework" title="Permalink"></a></h3><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Skogestad"><a class="tag is-link" href="#citeref-Skogestad">Skogestad</a>Skogestad, &quot;Multivariable Feedback Control: Analysis and Design&quot;</li><li class="footnote" id="footnote-Doyle91"><a class="tag is-link" href="#citeref-Doyle91">Doyle91</a>Doyle, Packard, Zhou, &quot;Review of LFTs, LMIs and μ&quot;. <a href="https://www.researchgate.net/publication/257200344_Review_of_LFTs_LMIs_and_mu"><code>https://www.researchgate.net/publication/257200344_Review_of_LFTs_LMIs_and_mu</code></a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 30 December 2021 07:55">Thursday 30 December 2021</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
